task.acc$cond<-factor(task.acc$cond,levels = c("no delay, no echo", "10ms delay, no echo","400ms delay, no echo","10ms delay, echo", "400ms delay, echo"))
task.acc$item<-as.factor(task.clean$item)
task.acc$sentence_id<-as.factor(task.clean$sentence_id)
task.acc$trial_counter_choice<-as.numeric(task.acc$trial_counter_choice)
task.acc$position<-as.factor(task.acc$position)
task.acc$position.cont<-as.factor(task.acc$position)
contrasts(task.acc$position.cont)<-contr.sum(2) #sum coded position variable
task.acc$latency<-factor(task.acc$latency,levels = c("0","10","400"))
task.acc$echo<-factor(task.acc$echo,levels = c("0","10","400"))
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
# m1.acc<-glmer(choice_response.corr~cond+position.cont+trial_counter_choice+(1+cond|participant)+(1+cond|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"), nAGQ = 1)
# summary(m1.acc)
#does not converge, simplify random effects structure:
# m1.acc<-glmer(choice_response.corr~cond+position.cont+trial_counter_choice+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"),
#     nAGQ = 1)
# summary(m1.acc)
#does not converge, rescale trial number to z-score
task.acc$trial.scal<-scale(task.acc$trial_counter_choice)
m1.acc<-glmer(choice_response.corr~cond+position.cont+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
# bobyqa = bound optimization by quadratic approximation
summary(m1.acc)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
task.acc$contrast10ms<-ifelse(task.acc$cond=="10ms delay, no echo", 1/2, ifelse(task.acc$cond=="10ms delay, echo", -1/2, 0))
task.acc$contrast400ms<-ifelse(task.acc$cond=="400ms delay, no echo", 1/2, ifelse(task.acc$cond=="400ms delay, echo", -1/2, 0))
m2.acc<-glmer(choice_response.corr~contrast10ms+contrast400ms+position.cont+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.acc)
m1.acc.expl<-glmer(choice_response.corr~cond*position+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.acc.expl)
#2. customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
m2.acc.expl<-glmer(choice_response.corr~contrast10ms*position+contrast400ms*position+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.acc.expl)
#factor coding
sj.clean$participant <- as.factor(sj.clean$participant)
sj.clean$cond <- factor(sj.clean$cond,levels = c("no delay, no echo", "10ms delay, no echo","400ms delay, no echo","10ms delay, echo", "400ms delay, echo"))
sj.clean$item <- as.factor(sj.clean$item)
sj.clean$sentence_id <- as.factor(sj.clean$sentence_id)
sj.clean$block_counter_sj <-as.factor(sj.clean$block_counter_sj)
sj.clean$trial_counter_sj <-as.numeric(sj.clean$trial_counter_sj)
sj.clean$latency <-factor(sj.clean$latency,levels = c("0","10","400"))
sj.clean$echo <-factor(sj.clean$echo,levels = c("0","10","400"))
sj.clean$response_distortion.corr<-factor(sj.clean$response_distortion.corr, levels = c("correct","incorrect"))
sj.clean$response_sync.corr <-factor(sj.clean$response_sync.corr, levels=c("correct","incorrect"))
sj.clean$response_distortion.keys<-factor(sj.clean$response_distortion.keys, levels = c("distorted","not distorted"))
sj.clean$response_sync.keys<-factor(sj.clean$response_sync.keys, levels=c("synced","not synced"))
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
#same as before, intercept-only model the only one that converges
m1.sync <- glmer(response_sync.keys~cond+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.sync)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
sj.clean$contrast10ms <- ifelse(sj.clean$cond == "10ms delay, no echo", 1/2, ifelse(sj.clean$cond == "10ms delay, echo", -1/2, 0))
sj.clean$contrast400ms <- ifelse(sj.clean$cond == "400ms delay, no echo", 1/2, ifelse(sj.clean$cond == "400ms delay, echo", -1/2, 0))
m2.sync <- glmer(response_sync.keys~contrast10ms+contrast400ms+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.sync)
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
#same as before, intercept-only model the only one that converges
m1.dist <- glmer(response_distortion.keys~cond+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.dist)
VarCorr(m1.dist)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
m2.dist <- glmer(response_distortion.keys ~ contrast10ms + contrast400ms + block_counter_sj + (1|participant) + (1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.dist)
VarCorr(m2.dist)
citation()
citation("lme4")
citation("ggplot2")
citation("Rmisc")
citation("scales")
citation("data.table")
citation("tidyverse")
citation("MASS")
citation("lmerTest")
citation("sjPlot")
citation("emmeans")
library(ggplot2)
library(Rmisc)
library(scales)
library(data.table)
library(tidyverse)
library(MASS)
library(lmerTest)
library(lme4)
library(sjPlot)
library(emmeans)
#replace this with your own file path
setwd("C:/Users/aron/Google Drive/BA/thesis/data_analysis/r_lme_analysis")
#load data
data <- read.csv("../data/corr_results.csv", header = T, comment.char = "#", stringsAsFactors=F)
framerate <- data%>%group_by(participant)%>%summarise(framerate=mean(frameRate))
#low frame rates (potentially exclude): 42,51,64,73,99
#low accuracy on fillers (see further below for accuracy on fillers):
#<80%: 64,73,79,89,90,94,99,113,121,123
#<75%: 64,90,94,123
#<70%: 90
#low accuracy on main trials (again, see below):
#<75%:
#<80%: 79
#low accuracy on all trials (<80%):
#79,90
#here, I remove all pilot participants, participants with an accuracy below 75% on the fillers, and the participant with an accuracy <80% on the main task
#We can discuss removing others as well, of course
#data <- filter(data, !data$participant%in%c(1:56,64,90,94,123))
data <- filter(data, !data$participant%in%c(1:56,79,90)) #1-56 are pilot, the other ones had low accuracy on the task
#---------------SJ judgment task------------------
sj<-data%>%filter(videoPath%like%"sj_videos")
#remove irrelevant columns
sj.clean<-sj[c("id","group","participant","cond","sentence_id","item","latency","echo","response_distortion.corr","response_distortion.keys","corrAns_distortion","response_sync.corr","response_sync.keys","corrAns_synchronicity","block_counter_sj","trial_counter_sj")]
#relabel condition variable
sj.clean$cond[sj.clean$cond==0]<-"no delay, no echo"
sj.clean$cond[sj.clean$cond==1]<-"10ms delay, no echo"
sj.clean$cond[sj.clean$cond==2]<-"400ms delay, no echo"
sj.clean$cond[sj.clean$cond==3]<-"10ms delay, echo"
sj.clean$cond[sj.clean$cond==4]<-"400ms delay, echo"
#relabel key variables
sj.clean$response_distortion.keys<-ifelse(sj.clean$response_distortion.keys=="left","distorted","not distorted")
sj.clean$response_sync.keys<-ifelse(sj.clean$response_sync.keys=="left","synced","not synced")
#relabel accuracy variables
sj.clean$response_sync.corr<-ifelse(sj.clean$response_sync.corr==0,"incorrect","correct")
sj.clean$response_distortion.corr<-ifelse(sj.clean$response_distortion.corr==0,"incorrect","correct")
#simple table of the data
table(sj.clean$cond,sj.clean$response_distortion.keys)
table(sj.clean$cond,sj.clean$response_distortion.corr)
table(sj.clean$cond,sj.clean$response_sync.keys)
table(sj.clean$cond,sj.clean$response_sync.corr)
table(sj.clean$cond,sj.clean$participant,sj.clean$response_sync.corr)
#save response as factor and re-order the response levels for nicer plotting
sj.clean$response_distortion.corr<-factor(sj.clean$response_distortion.corr, levels = c("incorrect","correct"))
sj.clean$response_distortion.keys<-factor(sj.clean$response_distortion.keys, levels = c("not distorted","distorted"))
sj_distortion_plot=ggplot(sj.clean,aes(x = cond,fill = response_distortion.corr)) +
geom_bar(position = "fill")+
geom_hline(yintercept=0.50, linetype="dashed",
color = "black", size=1.5)+
ylab("Proportion of correct responses")+
xlab("")+
theme_minimal() +
theme(axis.text.x = element_text(size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_distortion_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
sj_distortion2_plot=ggplot(sj.clean,aes(x = cond,fill = response_distortion.keys)) +
geom_bar(position = "fill")+
geom_hline(yintercept=0.50, linetype="dashed",
color = "black", size=1.5)+
ylab("Proportion of 'distorted' responses")+
xlab("")+
theme_minimal() +
theme(axis.text.x = element_text(size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_distortion2_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
sj_distortion3_plot=ggplot(sj.clean,aes(x = cond,fill = response_distortion.keys)) +facet_grid(~block_counter_sj)+
geom_bar(position = "fill")+
geom_hline(yintercept=0.50, linetype="dashed",
color = "black", size=1.5)+
ylab("Proportion of 'distorted' responses")+
xlab("")+
theme_minimal() +
#scale_x_discrete(labels=c("10ms+echo","10ms, no echo","400ms+echo","400ms, no echo","no delay, no echo")) +
theme(axis.text.x = element_text(angle=90, hjust=1,size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
strip.text.x = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_distortion3_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
#since we saw a lot of variation on the 400ms conditions, I overlayed the bar plot with individual subjects' mean responses. These must be calculated first, so...
sj.clean$response_sync.key.numeric<-ifelse(sj.clean$response_sync.keys=="synced",1,0)
sj.clean$response_sync.corr.numeric<-ifelse(sj.clean$response_sync.corr=="incorrect",0,1)
#individual participants' mean response on the sync question
summary.meanSync.subj<- ddply(sj.clean, c("participant", "cond"), summarise,
N    = length(response_sync.corr.numeric),
response_sync.corr = mean(response_sync.corr.numeric),
sd   = sd(response_sync.corr.numeric),
se   = sd / sqrt(N)
)
summary.meanSync.key.subj<- ddply(sj.clean, c("participant", "cond"), summarise,
N    = length(response_sync.key.numeric),
response_sync.key.numeric = mean(response_sync.key.numeric),
sd   = sd(response_sync.key.numeric),
se   = sd / sqrt(N)
)
#-----------------------------PLOTS----------------------------------------
sj_delay_plot=ggplot() +
geom_point(mapping=aes(x=cond, y=response_sync.corr, group=cond), data=summary.meanSync.subj, position=position_dodge2(width=.55),alpha = 1)+
geom_bar(data=sj.clean,aes(x = cond, fill = response_sync.corr),position = "fill", alpha=0.7)+
#geom_hline(yintercept=0.50, linetype="dashed", color = "black", size=1.5)+
ylab("Proportion of correct responses")+
xlab("")+
theme_minimal() +
theme(axis.text.x = element_text(size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_delay_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
sj_delay2_plot=ggplot() +
geom_point(mapping=aes(x=cond, y=response_sync.key.numeric, group=cond), data=summary.meanSync.key.subj, position=position_dodge2(width=.55),alpha = 1)+
geom_bar(data=sj.clean,aes(x = cond, fill = response_sync.keys),position = "fill", alpha=0.7)+
geom_bar(position = "fill")+
#geom_hline(yintercept=0.50, linetype="dashed", color = "black", size=1.5)+
ylab("Proportion of 'synchronous' responses")+
xlab("")+
theme_minimal() +
theme(axis.text.x = element_text(size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_delay2_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
#plus block info
sj_delay3_plot=ggplot(sj.clean,aes(x = cond,fill = response_sync.keys)) +facet_grid(~block_counter_sj)+
geom_bar(position = "fill")+
geom_hline(yintercept=0.50, linetype="dashed",
color = "black", size=1.5)+
ylab("Proportion of 'synchronous' responses")+
xlab("")+
theme_minimal() +
#scale_x_discrete(labels=c("10ms+echo","10ms, no echo","400ms+echo","400ms, no echo","no delay, no echo")) +
theme(axis.text.x = element_text(angle=90, hjust=1,size = rel(.75), color="black", face="bold"),
axis.title.x = element_text(size = rel(1), color="black", face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1), face="bold"),
strip.text.x = element_text(size = rel(1), face="bold"),
legend.position="none")
#---------------adding colour gradient to plot------------------
sj_delay3_plot+scale_color_manual(values = c("white","royalblue2" ))+
scale_fill_manual(values = c("white","royalblue2" ))
task<-data%>%filter(videoPath%like%"choice_videos")
#filter out traning trials
task.clean<-task%>%filter(is.na(training.thisIndex))
#remove irrelevant columns
task.clean<-task.clean[c("id","group","participant","cond","sentence_id","item","latency","echo","choice_response.corr","choice_response.keys","target_loc","choice_response.rt","corrAns_choice","show_attribute","attribute1","attribute2","imagePos","entity1","entity2","block_counter_choice","trial_counter_choice")]
#there were two sentences labeled as item 2. Here, I correct this:
task.clean$item[task.clean$item==2 & task.clean$entity1=="jäger"]<-161
#relabel conditions
task.clean$cond[task.clean$cond==0]<-"no delay, no echo"
task.clean$cond[task.clean$cond==1]<-"10ms delay, no echo"
task.clean$cond[task.clean$cond==2]<-"400ms delay, no echo"
task.clean$cond[task.clean$cond==3]<-"10ms delay, echo"
task.clean$cond[task.clean$cond==4]<-"400ms delay, echo"
#relabel target location
task.clean$target_loc<-ifelse(task.clean$target_loc==0,"right",ifelse(task.clean$target_loc==1,"left","up"))
#relabel accuracy variable
task.clean$choice_response.corr<-ifelse(task.clean$choice_response.corr==1,"correct","incorrect")
#save reaction time as numeric variable
task.clean$choice_response.rt=as.numeric(task.clean$choice_response.rt)
#recode in miliseconds
task.clean$choice_response.rt=task.clean$choice_response.rt*1000
#------------Filler trials----------------
task.fillers<-task.clean%>%filter(target_loc=="up")
#recoding response (left/right correct) for even-numbered subjects:
task.fillers$choice_response.corr[task.fillers$participant%%2==0]<-ifelse(task.fillers$choice_response.corr[task.fillers$participant%%2==0]=="incorrect", "correct", "incorrect")
task.clean2<-rbind(task.clean,task.fillers)
table(task.clean2$participant,task.clean2$choice_response.corr)
#low accuracy subjects should be removed
#--------------------main trials-----------------------
task.clean<-task.clean%>%filter(target_loc%in%c("left","right"))
#variable to indicate whether first or second noun was modified by the adjective
task.clean$position<-ifelse(task.clean$show_attribute==task.clean$attribute1, "first", "second")
table(task.clean$participant,task.clean$choice_response.corr)
#low accuracy subjects should be removed
table(task.clean$cond,task.clean$choice_response.corr)
#quick accuracy plot
#save response as factor and re-order the response levels for nicer plotting
task.clean$choice_response.corr<-factor(task.clean$choice_response.corr, levels = c("incorrect","correct"))
task_accuracy_plot=ggplot(task.clean,aes(x = cond,fill = choice_response.corr)) +
# facet_wrap(~position)+
geom_bar(position = "fill")+
geom_hline(yintercept=0.50, linetype="dashed",
color = "black", size=1.5)+
ylab("Proportion of correct responses")+
xlab("")+
theme_minimal() +
scale_x_discrete(labels=c("10ms \n +echo","10ms \n no echo","400ms \n +echo","400ms \n no echo","no delay \n no echo")) +
theme(axis.text.x = element_text(size = rel(.75), color="black", face="bold"))+
theme(axis.title.x = element_text(size = rel(1), color="black", face="bold"))+
theme(axis.title.y = element_text(size = rel(1), face="bold"))+
theme(axis.text.y = element_text(size = rel(1), face="bold"))+
theme(legend.text=element_text(size=rel(1), color="black", face="bold"))+
theme(strip.text.x = element_text(size = rel(1), face="bold"))+
theme(legend.title=element_blank(), legend.position="right", legend.text=element_text(size=rel(1), face="bold"))
#---------------adding colour gradient to plot------------------
task_accuracy_plot+scale_color_manual(values = c("deeppink4","royalblue2" ))+
scale_fill_manual(values = c("deeppink4","royalblue2" ))
#outlier removal: everything above and below 2.5 standard deviations from the mean per subject
#possibly include position as grouping variable, too
task.rt <- task.clean %>% group_by(participant) %>% filter(choice_response.rt<(mean(choice_response.rt)+2.5*sd(choice_response.rt))&choice_response.rt>(mean(choice_response.rt)-2.5*sd(choice_response.rt)))%>%ungroup()
#plot raw RT data
rt.raw.violin=ggplot(task.rt, aes(x=cond, y=choice_response.rt, fill=cond))+
geom_violin(size = 1, draw_quantiles = c(0.5),alpha=0.4) +
geom_point(aes(x=cond, y=choice_response.rt, group=cond, color=cond), position = position_jitterdodge(0.15), alpha = 0.9) +
theme_minimal() +
xlab("")+
ylab("Response time in ms")+
theme(axis.text.x = element_text(size = rel(.65), color="black"),
axis.title.x = element_text(size = rel(1), face="bold"),
axis.title.y = element_text(size = rel(1), face="bold"),
axis.text.y = element_text(size = rel(1)),
legend.text=element_text(size = rel(1), color="black"),
legend.title = element_text(size = rel(1), face="bold"))
rt.raw.violin
#possibly remove remaining outliers (visually detected)
#task.rt=subset(task.rt, task.rt$choice_response.rt>=)
#task.rt=subset(task.rt, task.rt$choice_response.rt<=)
hist(task.rt$choice_response.rt, breaks=100) #as you see, the distribution has two distinct peaks.
#plot by position of the target entity within the sentence
hist(task.rt$choice_response.rt[task.rt$position=="first"], breaks=100) #as you see, the distribution is not normal
hist(task.rt$choice_response.rt[task.rt$position=="second"], breaks=100) #as you see, the distribution is not normal
#check for the most appropriate transformation of the data (1=leave untransformed, 0=logRT, , 0.5=square root, -1=reciprocal transform). See Box, G. E. P., & Cox, D. R. (1964). An analysis of transformations. Journal of the Royal Statistical Society: Series B (Methodological), 26(2), 211–243. https://doi.org/10.1111/j.2517-6161.1964.tb00553.x
boxcox(choice_response.rt~cond*position, data=task.rt) #use sqrtRT
task.rt$logRT<-log(task.rt$choice_response.rt)
task.rt$sqrtRT<-sqrt(task.rt$choice_response.rt)
hist(task.rt$sqrtRT[task.rt$position=="first"], breaks=100) #as you see, the distribution is closer to normal
hist(task.rt$sqrtRT[task.rt$position=="second"], breaks=100) #as you see, the distribution is closer to normal
#Descriptive stats
summary.RT=summarySEwithin(task.rt, measurevar="choice_response.rt", withinvars=c("cond"))
summary.RT
summary.RT2=summarySEwithin(task.rt, measurevar="choice_response.rt", withinvars=c("position","cond"))
summary.RT2
RT.line=ggplot(data=summary.RT2, aes(x=cond, y=choice_response.rt, color=cond))+facet_wrap(~position)+
geom_errorbar(aes(ymin=choice_response.rt-se, ymax=choice_response.rt+se), size=.8, width=.2)+
geom_point(size=1.5)+
#scale_y_continuous(limits=c(2000,3500))+
ylab("Reaction time in ms")+
xlab("Conditions")+
theme_minimal() +
theme(axis.text.x = element_blank(),
axis.title.x = element_text(size = 10, color="black", face="bold"),
axis.title.y = element_text(size = 12, face="bold"),
axis.text.y = element_text(size = 12, face="bold"),
legend.text=element_text(size=12, color="black", face="bold"),
strip.text.x = element_text(size = 10, face="bold"),
legend.title=element_blank(), legend.position="right")
RT.line
rt.jitter=ggplot(task.rt, aes(x=cond, y=choice_response.rt, fill=cond))+
geom_boxplot(size = 1, notch=FALSE, outlier.shape = NA, alpha=0.4) +
geom_point(aes(x=cond, y=choice_response.rt, group=cond, color=cond), position = position_jitterdodge(0.3), alpha = 0.5) +
theme_minimal() +
xlab("")+
ylab("Reaction time in ms")+
theme(axis.text.x = element_text(size = 6, color="black", face="bold"),
axis.title.x = element_text(size = 10, color="black", face="bold"),
axis.title.y = element_text(size = 12, face="bold"),
axis.text.y = element_text(size = 12, face="bold"),
legend.text=element_text(size=12, color="black", face="bold"),
strip.text.x = element_text(size = 10, face="bold"),
legend.title=element_blank(), legend.position="right")
rt.jitter
rt.violin=ggplot(task.rt, aes(x=cond, y=choice_response.rt, fill=cond))+
geom_violin(size = 1, draw_quantiles = c(0.5),alpha=0.4) +
geom_point(aes(x=cond, y=choice_response.rt, group=cond, color=cond), position = position_jitterdodge(0.4), alpha = 0.5) +
theme_minimal() +
xlab("")+
ylab("Reaction time in ms")+
theme(axis.text.x = element_text(size = 6, color="black", face="bold"),
axis.title.x = element_text(size = 10, color="black", face="bold"),
axis.title.y = element_text(size = 12, face="bold"),
axis.text.y = element_text(size = 12, face="bold"),
legend.text=element_text(size=12, color="black", face="bold"),
strip.text.x = element_text(size = 10, face="bold"),
legend.title=element_blank(), legend.position="right")
rt.violin
#factor coding
task.rt$participant<-as.factor(task.rt$participant)
task.rt$sentence_id<-as.factor(task.rt$sentence_id)
task.rt$trial_counter_choice<-as.numeric(task.rt$trial_counter_choice)
task.rt$position<-as.factor(task.rt$position)
task.rt$position.cont<-as.factor(task.rt$position)
contrasts(task.rt$position.cont)<-contr.sum(2) #sum coded position variable
task.rt$cond<-factor(task.rt$cond,levels = c("no delay, no echo", "10ms delay, no echo","400ms delay, no echo","10ms delay, echo", "400ms delay, echo"))
task.rt$latency<-factor(task.rt$latency,levels = c("0","10","400"))
task.rt$echo<-factor(task.rt$echo,levels = c("0","10","400"))
task.rt$trial_counter_choice.scal<-scale(task.rt$trial_counter_choice)
#-------------------------contrast coding-------------------------------------
#Please note that the following models (m1.rt and m2.rt) do not include an interaction with position. This was so that you have an "easy" entry to lmems. For your thesis, you should only report the model with interaction term, see the next code block.
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
#m1.rt<-lmer(sqrtRT~cond+position.cont+trial_counter_choice+(1+cond|participant)+(1+cond|sentence_id), data=task.rt)
# summary(m1.rt)
#singular fit with the model above, simplify random effects structure:
m1.rt<-lmer(sqrtRT~cond+position.cont+trial_counter_choice.scal+(1|participant)+(1|sentence_id), data=task.rt)
summary(m1.rt)
#here's how the p-value is calculated. Just tested it, the outcome is the same as if using lmerTest. Just note that once you activate the lmerTest package (using library(lmerTest) in the code) all lmer() commands will use the lmerTest package, not lme4!
coefs <- data.frame(coef(summary(m1.rt)))
coefs$p <- format.pval(2*(1-pnorm(abs(coefs$t.value))), digits=2, eps=0.0001) #caculate p-value, round to 2 digits
coefs
plot_model(m1.rt,type="diag")
#plot(m1.rt, pars = "^b_")
#df calculation can take a while
emmeans(m1.rt, pairwise~cond, adjust="tukey",pbkrtest.limit = 4002)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
task.rt$contrast10ms <- ifelse(task.rt$cond=="10ms delay, no echo", 1/2, ifelse(task.rt$cond=="10ms delay, echo", -1/2, 0))
task.rt$contrast400ms <- ifelse(task.rt$cond=="400ms delay, no echo", 1/2, ifelse(task.rt$cond=="400ms delay, echo", -1/2, 0))
# m2.rt<-lmer(sqrtRT~contrast10ms+contrast400ms+trial_counter_choice+position.cont+(1+contrast10ms+contrast400ms|participant)+(1+contrast10ms+contrast400ms|sentence_id), data=subset(task.rt, !task.rt$cond%in%c("no delay, no echo")))
# summary(m2.rt)
#simplified random effects
m2.rt <- lmer(sqrtRT~contrast10ms+contrast400ms+trial_counter_choice.scal+position.cont+(1|participant)+(1|sentence_id), data=subset(task.rt, !task.rt$cond%in%c("no delay, no echo")))
summary(m2.rt)
coefs <- data.frame(coef(summary(m2.rt)))
coefs$p <- format.pval(2*(1-pnorm(abs(coefs$t.value))), digits=2, eps=0.0001) #caculate p-value, round to 2 digits
coefs
m1.expl.rt<-lmer(sqrtRT~cond*position+trial_counter_choice.scal+(1|participant)+(1|sentence_id), data=task.rt)
summary(m1.expl.rt)
coefs <- data.frame(coef(summary(m1.expl.rt)))
coefs$p <- format.pval(2*(1-pnorm(abs(coefs$t.value))), digits=2, eps=0.0001) #caculate p-value, round to 2 digits
coefs
#2. customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
m2.expl.rt<-lmer(sqrtRT~contrast10ms*position+contrast400ms*position+trial_counter_choice.scal+(1|participant)+(1|sentence_id), data=subset(task.rt, !task.rt$cond%in%c("no delay, no echo")))
summary(m2.expl.rt)
coefs <- data.frame(coef(summary(m2.expl.rt)))
coefs$p <- format.pval(2*(1-pnorm(abs(coefs$t.value))), digits=2, eps=0.0001) #caculate p-value, round to 2 digits
coefs
task.acc<-task.clean
#factor coding
task.acc$participant<-as.factor(task.acc$participant)
task.acc$cond<-factor(task.acc$cond,levels = c("no delay, no echo", "10ms delay, no echo","400ms delay, no echo","10ms delay, echo", "400ms delay, echo"))
task.acc$item<-as.factor(task.clean$item)
task.acc$sentence_id<-as.factor(task.clean$sentence_id)
task.acc$trial_counter_choice<-as.numeric(task.acc$trial_counter_choice)
task.acc$position<-as.factor(task.acc$position)
task.acc$position.cont<-as.factor(task.acc$position)
contrasts(task.acc$position.cont)<-contr.sum(2) #sum coded position variable
task.acc$latency<-factor(task.acc$latency,levels = c("0","10","400"))
task.acc$echo<-factor(task.acc$echo,levels = c("0","10","400"))
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
# m1.acc<-glmer(choice_response.corr~cond+position.cont+trial_counter_choice+(1+cond|participant)+(1+cond|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"), nAGQ = 1)
# summary(m1.acc)
#does not converge, simplify random effects structure:
# m1.acc<-glmer(choice_response.corr~cond+position.cont+trial_counter_choice+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"),
#     nAGQ = 1)
# summary(m1.acc)
#does not converge, rescale trial number to z-score
task.acc$trial.scal<-scale(task.acc$trial_counter_choice)
m1.acc<-glmer(choice_response.corr~cond+position.cont+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
# bobyqa = bound optimization by quadratic approximation
summary(m1.acc)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
task.acc$contrast10ms<-ifelse(task.acc$cond=="10ms delay, no echo", 1/2, ifelse(task.acc$cond=="10ms delay, echo", -1/2, 0))
task.acc$contrast400ms<-ifelse(task.acc$cond=="400ms delay, no echo", 1/2, ifelse(task.acc$cond=="400ms delay, echo", -1/2, 0))
m2.acc<-glmer(choice_response.corr~contrast10ms+contrast400ms+position.cont+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.acc)
m1.acc.expl<-glmer(choice_response.corr~cond*position+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.acc.expl)
#2. customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
m2.acc.expl<-glmer(choice_response.corr~contrast10ms*position+contrast400ms*position+trial.scal+(1|participant)+(1|sentence_id), data=task.acc,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.acc.expl)
#factor coding
sj.clean$participant <- as.factor(sj.clean$participant)
sj.clean$cond <- factor(sj.clean$cond,levels = c("no delay, no echo", "10ms delay, no echo","400ms delay, no echo","10ms delay, echo", "400ms delay, echo"))
sj.clean$item <- as.factor(sj.clean$item)
sj.clean$sentence_id <- as.factor(sj.clean$sentence_id)
sj.clean$block_counter_sj <-as.factor(sj.clean$block_counter_sj)
sj.clean$trial_counter_sj <-as.numeric(sj.clean$trial_counter_sj)
sj.clean$latency <-factor(sj.clean$latency,levels = c("0","10","400"))
sj.clean$echo <-factor(sj.clean$echo,levels = c("0","10","400"))
sj.clean$response_distortion.corr<-factor(sj.clean$response_distortion.corr, levels = c("correct","incorrect"))
sj.clean$response_sync.corr <-factor(sj.clean$response_sync.corr, levels=c("correct","incorrect"))
sj.clean$response_distortion.keys<-factor(sj.clean$response_distortion.keys, levels = c("distorted","not distorted"))
sj.clean$response_sync.keys<-factor(sj.clean$response_sync.keys, levels=c("synced","not synced"))
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
#same as before, intercept-only model the only one that converges
m1.sync <- glmer(response_sync.keys~cond+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.sync)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
sj.clean$contrast10ms <- ifelse(sj.clean$cond == "10ms delay, no echo", 1/2, ifelse(sj.clean$cond == "10ms delay, echo", -1/2, 0))
sj.clean$contrast400ms <- ifelse(sj.clean$cond == "400ms delay, no echo", 1/2, ifelse(sj.clean$cond == "400ms delay, echo", -1/2, 0))
m2.sync <- glmer(response_sync.keys~contrast10ms+contrast400ms+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.sync)
#-------------------------contrast coding-------------------------------------
#1. treatment contrasts: automatically uses the first factor setting defined above as reference against which all others are checked
#same as before, intercept-only model the only one that converges
m1.dist <- glmer(response_distortion.keys~cond+block_counter_sj+(1|participant)+(1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m1.dist)
VarCorr(m1.dist)
#2. within the four main conditions, customized contrasts for the hypotheses at hand: check 10ms no echo against 10ms w/ echo, check 400ms no echo against 400ms w/ echo
m2.dist <- glmer(response_distortion.keys ~ contrast10ms + contrast400ms + block_counter_sj + (1|participant) + (1|sentence_id), data = sj.clean,family = binomial, control = glmerControl(optimizer = "bobyqa"))
summary(m2.dist)
VarCorr(m2.dist)
citation()
citation("lme4")
citation("ggplot2")
citation("Rmisc")
citation("scales")
citation("data.table")
citation("tidyverse")
citation("MASS")
citation("lmerTest")
citation("sjPlot")
citation("emmeans")
View(framerate)
participants <- data%>%group_by(participant)%>%summarise(participant)
View(participants)
participants <- data%>%group_by(participant)%>%summarise(unique(participant))
View(participants)
View(participants)
